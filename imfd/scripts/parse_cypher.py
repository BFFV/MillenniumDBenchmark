import os
import sys
from shutil import rmtree


# Parse path inside query
def parse_path(p):
    parsed_path = ''
    ignore = False
    nodes = 0
    for idx in range(len(p)):
        char = p[idx]
        if char == '(' and p[idx + 1] != ')':
            nodes += 1
            if nodes > 1:
                parsed_path += ']=>'
            parsed_path += '(?'
            ignore = False
            continue
        elif char == ')' and not ignore and nodes < 2:
            parsed_path += ')=['
            continue
        elif char == '(' and p[idx + 1] == ')':
            parsed_path += '/'
        elif char == '<':
            parsed_path += '^'
            ignore = True
        elif char == '-':
            ignore = True
        elif char == '[':
            ignore = False
            parsed_path += '('
            continue
        elif char == ']':
            ignore = True
            if parsed_path[-1] != '+':
                parsed_path += ')'
        elif char == '|':
            parsed_path += '|:'
            continue
        elif char == '*':
            parsed_path += ')+'
            continue
        if not ignore:
            parsed_path += char
    return parsed_path.replace(',', '') + '\n'


# Cypher to MillenniumDB query syntax
def parse_query(in_query, out_query):
    with open(in_query, 'r') as in_file:
        query = in_file.readline().strip('\n')
        return_idx = query.find('RETURN')
        limit_idx = query.find('LIMIT')
        boolean = False
        if limit_idx > 0:
            boolean = True
        query = query[:return_idx]
        query_paths = query.strip().split(' ')[1:]
        for idx, path in enumerate(query_paths):
            if boolean:
                return_syntax = 'RETURN *\nLIMIT 1'
            else:
                stripped_path = path.strip().replace(',', '')
                var_a = stripped_path[1: 3]
                var_b = stripped_path[-3: -1]
                return_syntax = f'RETURN DISTINCT ?{var_a}, ' \
                                f'?{var_b}\nLIMIT 1000'
            mdb_query = 'MATCH ' + parse_path(path) + return_syntax
            with open(f'{out_query}_{idx}', 'w') as out_file:
                out_file.write(mdb_query)


# Parse Cypher queries generated by gMark
if __name__ == '__main__':
    try:
        in_dir = sys.argv[1]
        out_dir = sys.argv[2]
        rmtree(out_dir, ignore_errors=True)
        os.mkdir(out_dir)
        for subdir, dirs, files in os.walk(in_dir):
            for file in files:
                if file.endswith('.cypher'):
                    parse_query(os.path.join(subdir, file),
                                os.path.join(out_dir, f'{file[:-7]}'))
    except IndexError:
        print('Args are missing!')
