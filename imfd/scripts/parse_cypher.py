import os
import sys
from shutil import rmtree


# Parse path inside query
def parse_path(p):
    parsed_path = ''
    ignore = False
    nodes = 0
    for idx in range(len(p)):
        char = p[idx]
        if char == '(' and p[idx + 1] != ')':
            nodes += 1
            if nodes > 1:
                parsed_path += ']=>'
            parsed_path += '(?'
            ignore = False
            continue
        elif char == ')' and not ignore and nodes < 2:
            parsed_path += ')=['
            continue
        elif char == '(' and p[idx + 1] == ')':
            parsed_path += '/'
        elif char == '<':
            parsed_path += '^'
            ignore = True
        elif char == '-':
            ignore = True
        elif char == '[':
            ignore = False
            parsed_path += '('
            continue
        elif char == ']':
            ignore = True
            if parsed_path[-1] != '+':
                parsed_path += ')'
        elif char == '|':
            parsed_path += '|:'
            continue
        elif char == '*':
            parsed_path += ')+'
            continue
        if not ignore:
            parsed_path += char
    return parsed_path + '\n'


# Cypher to MillenniumDB query syntax
def parse_query(in_query, out_query):
    mdb_query = 'MATCH '
    with open(in_query, 'r') as in_file:
        query = in_file.readline().strip('\n')
        return_idx = query.find('RETURN')
        limit_idx = query.find('LIMIT')
        limit_str = '\nLIMIT 1000'
        if limit_idx < 0:
            limit_idx = len(query)
        else:
            limit_str = '\n' + query[limit_idx: -1]
        return_syntax = query[return_idx: limit_idx].strip().split(' ')
        if len(return_syntax) < 3:
            return_syntax[1] = '*'
            return_syntax = ' '.join(return_syntax[:2])
        else:
            return_syntax = ' '.join(return_syntax[:2]) + ' ' + \
                            ' '.join(map(lambda s: '?' + s.replace(';', ''),
                                         return_syntax[2:]))
        query = query[:return_idx]
        query_paths = query.strip().split(' ')[1:]
        for idx, path in enumerate(query_paths):
            if idx:
                mdb_query += 6 * ' '
            mdb_query += parse_path(path)
        mdb_query += return_syntax
        mdb_query += limit_str
    with open(out_query, 'w') as out_file:
        out_file.write(mdb_query)


# Parse Cypher queries generated by gMark
if __name__ == '__main__':
    try:
        in_dir = sys.argv[1]
        out_dir = sys.argv[2]
        rmtree(out_dir, ignore_errors=True)
        os.mkdir(out_dir)
        for subdir, dirs, files in os.walk(in_dir):
            for file in files:
                if file.endswith('.cypher'):
                    parse_query(os.path.join(subdir, file),
                                os.path.join(out_dir, f'{file[:-7]}'))
    except IndexError:
        print('Args are missing!')
